# Boggle Assignment

## The Game

This application is an Backend API for a game of Boggle.
Read [HERE](https://en.wikipedia.org/wiki/Boggle) to understand more about the game.

This application makes one modification to the original game. Now it is possible for one or more of the letter tiles to be blank (denoted by *). When a tile is blank, it can be treated as any other letter.

## Commands for playing

To create a new game input this into your prefered CLI interface

`curl -d 'Accept: application/json' https://shihao-boggle-assignment.herokuapp.com/games | json_pp`

After you've created a new game, you would receive a JSON response like this

```
{
  "token" : "123abc",
  "board" : [
    "R V N S",
    "K W M E",
    "S B * T",
    "A * L I"
   ],
  "success_message" : "New game created! You have 5mins to play"
}
```

This response provides the game `TOKEN` and `BOARD` which are needed to play the game.

To play the game, you need to provide a `VALID TOKEN` and `ANSWER` to an API endpoint. 

Following the above example, it would be like this

`curl -X PUT -d 'token=123abc&answer=BAT' 'Accept: application/json' https://shihao-boggle-assignment.herokuapp.com/games/play | json_pp`

Depending on whether your answer is correct, you will get a different response.

If the answer is valid, it might look like this

```
{
  "time_left" : "102 seconds",
  "correct_words" : [
      "BAT"
  ],
  "current_points" : 3,
  "board" : [
    "R V N S",
    "K W M E",
    "S B * T",
    "A * L I"
  ],
  "success_message" : "BAT is a valid word",
  "error_messages" : []
}
```

If it's invalid it might look something like this

```
{
  "error_messages" : [
    "HELLO cannot be found on game board"
  ],
  "time_left" : "70 seconds",
  "board" : [
    "R V N S",
    "K W M E",
    "S B * T",
    "A * L I"
  ]
}
```

Each game only last for 5minutes. So if you try to call the PUT API endpoint after the game has ended. You are expected to receive a JSON response like this.

```
{
  "error_messages" : [
    "This game has completed. The final result was 3 points"
  ],
  "board" : [
    "R V N S",
    "K W M E",
    "S B * T",
    "A * L I"
  ],
  "time_left" : "This game has completed"
}
```

Have fun playing!

##Design implementations

###Models

I decided to create two models for this application: Game and Result.

All Result belong to a Game. And all Game have one Result. As these models can be
referenced both ways, I decided to add mutual destroy dependency for them.

Each game should have a unique token generated by `SecureRandom.hex(20)`

In terms of model design, the Game model stores all attributes related to how to play the game(token, board) and whether it can still be played(start_time, end_time, completed).

And the Result model stores attributes related to the outcome of the game(points, correct_answers). 

###Controllers

This application only has one controller(GamesController) with two methods in it. 

```
/games - POST - games#create
/games/play - PUT - games#play
```

`games#create` is responsible for creating a new game. 

A Game should always be created successfully unless it generates a similar token as a previous game.

Due to the extremely slim chance(less than one in a septillion) of a duplicated token, I choose to return a JSON error message if the creation fails instead of writing a more complex `generate_token` method on the model level.

`games#play` is responsible for allowing the user to play the game they've created. 

Before this action happens, `check_missing_params` will check if either token or answer params are blank. If any of them are blank, a JSON error will be returned.

Assuming both token and answer are passed in, the play method will attempt to find a Game with the given token. If a Game is found, it will trigger `GameBoard::ValidateAnswer` service class and return a JSON response depending on the result. If not, it will return a JSON error message telling the player the game token is not valid.

### Caching

To access the large dictionary as efficiently as possible. I decided to group the dictionary into seperate keys based on its first two letters and the word length.

For example

```
{ 
  "HE_5": [ "hello", "heard" ],
  "WO_5: [ "world", "would" ],
  "BO_3: [ "boy", "boa"]
}
```

I also found all possible word lengths based on the provided dictionary and stored the length of its longest and shortest word.

Using `Rails.cache` I cached the grouped dictionary and shortest/longest word length in Redis through a rake file. This rake file can be run anytime the dictionary is updated.

###Services

As not to clog up the controllers or models with game logic, I created a service class(`GameBoard::ValidateAnswer`) to handle the validation of an answer.

This service class is split up into three parts

1. Check if game is completed
2. Check if answer is possible
3. Check if answer can be found on board

To return the response as quickly as possible, if any of these parts returns an error message, it will cut short the service and not continue to the next part.

Part 1 checks if the game has already completed based on either the completed boolean or if the current time is later than the end time.

Part 2 checks if the given answer is possible. For an answer to be considered as possible, it needs to fulfill the following rules

- Must only contain english letters
- Length must be between the shortest(3) and longest(8) word in cached dictionary
- Must be a word that can be found on cached dictionary
- Cannot be answered correctly before

In the same order, if the answer breaks any of the first two rules, it will not continue to check the next one.(Eg. If an answer has 10 characters it cannot exist in the dictionary; If an answer does not exist in the dictionary, it cannot be answered correctly before)

Part 3 checks if the answer can be found on the board. To do this, I... 

1. Find all the starting coordinates on the board.
2. Loop through the starting coordinates and find the neighbours for each of them
3. Loop through the neighbours and if a neighbour letter matches the letter I'm looking for, increase the `answer_letter_index` and create a recursion that repeats step 3
4. If the `answer_letter_index` is similar to the answer length it means that the given answer can be found on the board 

Finally, it updates the result with the given word if it passes all rounds of validations.